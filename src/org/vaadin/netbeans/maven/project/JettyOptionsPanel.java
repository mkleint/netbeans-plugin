/*
 * Copyright 2000-2013 Vaadin Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package org.vaadin.netbeans.maven.project;

import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.File;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;

import javax.swing.DefaultComboBoxModel;
import javax.swing.DefaultListModel;
import javax.swing.JFileChooser;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.xml.namespace.QName;

import org.apache.maven.project.MavenProject;
import org.netbeans.api.progress.ProgressUtils;
import org.netbeans.api.project.Project;
import org.netbeans.modules.maven.api.NbMavenProject;
import org.netbeans.modules.maven.api.customizer.ModelHandle2;
import org.netbeans.modules.maven.model.ModelOperation;
import org.netbeans.modules.maven.model.Utilities;
import org.netbeans.modules.maven.model.pom.Configuration;
import org.netbeans.modules.maven.model.pom.POMExtensibilityElement;
import org.netbeans.modules.maven.model.pom.POMModel;
import org.netbeans.modules.maven.model.pom.Plugin;
import org.openide.filesystems.FileObject;
import org.openide.filesystems.FileUtil;
import org.openide.util.Lookup;
import org.openide.util.NbBundle;

/**
 * @author denis
 */
public class JettyOptionsPanel extends javax.swing.JPanel {

    private static final String WEB_APP = "webApp"; // NOI18N

    private static final String CONTEXT_PATH = "contextPath"; // NOI18N

    private static final String SCAN_INTERVAL_SECONDS = "scanIntervalSeconds"; // NOI18N

    private static final String RELOAD = "reload"; // NOI18N

    private static final String CLASSES_DIRECTORY = "classesDirectory"; // NOI18N

    private static final String BASE_DIR = "${basedir}"; // NOI18N

    private static final String SCAN_TARGETS = "scanTargets"; // NOI18N

    private static final String SCAN_TARGET = SCAN_TARGETS.substring(0,
            SCAN_TARGETS.length() - 1);

    public JettyOptionsPanel( Lookup context ) {
        initComponents();

        myProject = context.lookup(Project.class);

        DefaultComboBoxModel<ReloadMode> model = new DefaultComboBoxModel<>();
        model.addElement(ReloadMode.AUTOMATIC);
        model.addElement(ReloadMode.MANUAL);
        myReload.setModel(model);

        myScanTargets.setModel(new DefaultListModel<String>());

        myHandle = context.lookup(ModelHandle2.class);
        myOperation = new JettyModification();

        DocumentListener documentListener = new DocumentListener() {

            @Override
            public void removeUpdate( DocumentEvent e ) {
                update();
            }

            @Override
            public void insertUpdate( DocumentEvent e ) {
                update();
            }

            @Override
            public void changedUpdate( DocumentEvent e ) {
                update();
            }

            private void update() {
                addModification();
            }
        };

        myReload.addItemListener(new ItemListener() {

            @Override
            public void itemStateChanged( ItemEvent e ) {
                myScanInterval.setEnabled(!myReload.getSelectedItem().equals(
                        ReloadMode.MANUAL));
                addModification();
            }
        });

        myOutputDir.getDocument().addDocumentListener(documentListener);
        myCtxtPath.getDocument().addDocumentListener(documentListener);

        setValues();

    }

    @NbBundle.Messages("readingJettyOptions=Retrieving options...")
    private void setValues() {
        ProgressUtils.showProgressDialogAndRun(new InitRunnable(),
                Bundle.readingJettyOptions());
    }

    private void addModification() {
        List<ModelOperation<POMModel>> pomOperations = myHandle
                .getPOMOperations();
        for (ModelOperation<POMModel> operation : pomOperations) {
            if (operation instanceof JettyModification) {
                myHandle.removePOMModification(operation);
            }
        }
        myHandle.addPOMModification(myOperation);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTextField1 = new javax.swing.JTextField();
        classesDir = new javax.swing.JLabel();
        myOutputDir = new javax.swing.JTextField();
        reloadLbl = new javax.swing.JLabel();
        myReload = new javax.swing.JComboBox();
        canIntervalLbl = new javax.swing.JLabel();
        myScanInterval = new javax.swing.JSpinner();
        scanPanel = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        myScanTargets = new javax.swing.JList();
        myAddScan = new javax.swing.JButton();
        myRemoveScan = new javax.swing.JButton();
        cntxtPathLbl = new javax.swing.JLabel();
        myCtxtPath = new javax.swing.JTextField();

        jTextField1.setText(org.openide.util.NbBundle.getMessage(
                JettyOptionsPanel.class, "JettyOptionsPanel.jTextField1.text")); // NOI18N

        classesDir.setLabelFor(myOutputDir);
        org.openide.awt.Mnemonics.setLocalizedText(classesDir,
                org.openide.util.NbBundle.getMessage(JettyOptionsPanel.class,
                        "LBL_JettyClassesDir")); // NOI18N

        reloadLbl.setLabelFor(myReload);
        org.openide.awt.Mnemonics.setLocalizedText(reloadLbl,
                org.openide.util.NbBundle.getMessage(JettyOptionsPanel.class,
                        "LBL_Reload")); // NOI18N

        canIntervalLbl.setLabelFor(myScanInterval);
        org.openide.awt.Mnemonics.setLocalizedText(canIntervalLbl,
                org.openide.util.NbBundle.getMessage(JettyOptionsPanel.class,
                        "LBL_JettyScanInterval")); // NOI18N

        scanPanel.setBorder(javax.swing.BorderFactory
                .createTitledBorder(org.openide.util.NbBundle.getMessage(
                        JettyOptionsPanel.class, "LBL_ScanTargetsTitle"))); // NOI18N

        jScrollPane1.setViewportView(myScanTargets);

        org.openide.awt.Mnemonics.setLocalizedText(myAddScan,
                org.openide.util.NbBundle.getMessage(JettyOptionsPanel.class,
                        "LBL_AddScan")); // NOI18N
        myAddScan.addActionListener(new java.awt.event.ActionListener() {

            public void actionPerformed( java.awt.event.ActionEvent evt ) {
                showFileChoser(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(myRemoveScan,
                org.openide.util.NbBundle.getMessage(JettyOptionsPanel.class,
                        "LBL_Remove")); // NOI18N
        myRemoveScan.addActionListener(new java.awt.event.ActionListener() {

            public void actionPerformed( java.awt.event.ActionEvent evt ) {
                removeSelectedTargets(evt);
            }
        });

        javax.swing.GroupLayout scanPanelLayout = new javax.swing.GroupLayout(
                scanPanel);
        scanPanel.setLayout(scanPanelLayout);
        scanPanelLayout
                .setHorizontalGroup(scanPanelLayout
                        .createParallelGroup(
                                javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(
                                scanPanelLayout
                                        .createSequentialGroup()
                                        .addGap(7, 7, 7)
                                        .addComponent(jScrollPane1)
                                        .addPreferredGap(
                                                javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addGroup(
                                                scanPanelLayout
                                                        .createParallelGroup(
                                                                javax.swing.GroupLayout.Alignment.LEADING,
                                                                false)
                                                        .addComponent(
                                                                myRemoveScan,
                                                                javax.swing.GroupLayout.DEFAULT_SIZE,
                                                                javax.swing.GroupLayout.DEFAULT_SIZE,
                                                                Short.MAX_VALUE)
                                                        .addComponent(
                                                                myAddScan,
                                                                javax.swing.GroupLayout.DEFAULT_SIZE,
                                                                javax.swing.GroupLayout.DEFAULT_SIZE,
                                                                Short.MAX_VALUE))
                                        .addContainerGap()));
        scanPanelLayout
                .setVerticalGroup(scanPanelLayout
                        .createParallelGroup(
                                javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(
                                scanPanelLayout
                                        .createSequentialGroup()
                                        .addComponent(myAddScan)
                                        .addPreferredGap(
                                                javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(myRemoveScan)
                                        .addContainerGap(
                                                javax.swing.GroupLayout.DEFAULT_SIZE,
                                                Short.MAX_VALUE))
                        .addComponent(jScrollPane1,
                                javax.swing.GroupLayout.DEFAULT_SIZE, 154,
                                Short.MAX_VALUE));

        cntxtPathLbl.setLabelFor(myCtxtPath);
        org.openide.awt.Mnemonics.setLocalizedText(cntxtPathLbl,
                org.openide.util.NbBundle.getMessage(JettyOptionsPanel.class,
                        "LBL_CntxtPath")); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(layout
                .createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(
                        layout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(
                                        layout.createParallelGroup(
                                                javax.swing.GroupLayout.Alignment.LEADING)
                                                .addComponent(
                                                        scanPanel,
                                                        javax.swing.GroupLayout.DEFAULT_SIZE,
                                                        javax.swing.GroupLayout.DEFAULT_SIZE,
                                                        Short.MAX_VALUE)
                                                .addGroup(
                                                        layout.createSequentialGroup()
                                                                .addGroup(
                                                                        layout.createParallelGroup(
                                                                                javax.swing.GroupLayout.Alignment.LEADING)
                                                                                .addComponent(
                                                                                        reloadLbl)
                                                                                .addComponent(
                                                                                        classesDir)
                                                                                .addComponent(
                                                                                        cntxtPathLbl))
                                                                .addPreferredGap(
                                                                        javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                                .addGroup(
                                                                        layout.createParallelGroup(
                                                                                javax.swing.GroupLayout.Alignment.LEADING)
                                                                                .addGroup(
                                                                                        layout.createSequentialGroup()
                                                                                                .addComponent(
                                                                                                        myReload,
                                                                                                        javax.swing.GroupLayout.PREFERRED_SIZE,
                                                                                                        184,
                                                                                                        javax.swing.GroupLayout.PREFERRED_SIZE)
                                                                                                .addGap(18,
                                                                                                        18,
                                                                                                        Short.MAX_VALUE)
                                                                                                .addComponent(
                                                                                                        canIntervalLbl)
                                                                                                .addPreferredGap(
                                                                                                        javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                                                                .addComponent(
                                                                                                        myScanInterval,
                                                                                                        javax.swing.GroupLayout.PREFERRED_SIZE,
                                                                                                        51,
                                                                                                        javax.swing.GroupLayout.PREFERRED_SIZE))
                                                                                .addComponent(
                                                                                        myOutputDir)
                                                                                .addComponent(
                                                                                        myCtxtPath))))
                                .addContainerGap()));
        layout.setVerticalGroup(layout
                .createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(
                        layout.createSequentialGroup()
                                .addContainerGap()
                                .addGroup(
                                        layout.createParallelGroup(
                                                javax.swing.GroupLayout.Alignment.BASELINE)
                                                .addComponent(classesDir)
                                                .addComponent(
                                                        myOutputDir,
                                                        javax.swing.GroupLayout.PREFERRED_SIZE,
                                                        javax.swing.GroupLayout.DEFAULT_SIZE,
                                                        javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(7, 7, 7)
                                .addGroup(
                                        layout.createParallelGroup(
                                                javax.swing.GroupLayout.Alignment.BASELINE)
                                                .addComponent(cntxtPathLbl)
                                                .addComponent(
                                                        myCtxtPath,
                                                        javax.swing.GroupLayout.PREFERRED_SIZE,
                                                        javax.swing.GroupLayout.DEFAULT_SIZE,
                                                        javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(
                                        javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(
                                        layout.createParallelGroup(
                                                javax.swing.GroupLayout.Alignment.BASELINE)
                                                .addComponent(reloadLbl)
                                                .addComponent(
                                                        myReload,
                                                        javax.swing.GroupLayout.PREFERRED_SIZE,
                                                        javax.swing.GroupLayout.DEFAULT_SIZE,
                                                        javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addComponent(canIntervalLbl)
                                                .addComponent(
                                                        myScanInterval,
                                                        javax.swing.GroupLayout.PREFERRED_SIZE,
                                                        javax.swing.GroupLayout.DEFAULT_SIZE,
                                                        javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(18, 18, 18)
                                .addComponent(scanPanel,
                                        javax.swing.GroupLayout.DEFAULT_SIZE,
                                        javax.swing.GroupLayout.DEFAULT_SIZE,
                                        Short.MAX_VALUE).addContainerGap()));

        classesDir.getAccessibleContext().setAccessibleName(
                org.openide.util.NbBundle.getMessage(JettyOptionsPanel.class,
                        "ACSN_JettyOutputDir")); // NOI18N
        classesDir.getAccessibleContext().setAccessibleDescription(
                org.openide.util.NbBundle.getMessage(JettyOptionsPanel.class,
                        "ACSD_JettyOutputDir")); // NOI18N
        cntxtPathLbl.getAccessibleContext().setAccessibleName(
                org.openide.util.NbBundle.getMessage(JettyOptionsPanel.class,
                        "ACSN_CntxtPath")); // NOI18N
        cntxtPathLbl.getAccessibleContext().setAccessibleDescription(
                org.openide.util.NbBundle.getMessage(JettyOptionsPanel.class,
                        "ACSD_CtxtPath")); // NOI18N
        myCtxtPath.getAccessibleContext().setAccessibleName(
                cntxtPathLbl.getAccessibleContext().getAccessibleName());
        myCtxtPath.getAccessibleContext().setAccessibleDescription(
                cntxtPathLbl.getAccessibleContext().getAccessibleDescription());
    }// </editor-fold>//GEN-END:initComponents

    @NbBundle.Messages("chooseTarget=Choose Additional Scan Target")
    private void showFileChoser( java.awt.event.ActionEvent evt ) {//GEN-FIRST:event_showFileChoser
        JFileChooser chooser = new JFileChooser();
        chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
        chooser.setMultiSelectionEnabled(true);

        chooser.setCurrentDirectory(FileUtil.toFile(myProject
                .getProjectDirectory()));
        chooser.setDialogTitle(Bundle.chooseTarget());
        if (JFileChooser.APPROVE_OPTION == chooser.showOpenDialog(this)) { //NOI18N
            for (File file : chooser.getSelectedFiles()) {
                file = FileUtil.normalizeFile(file);
                FileObject chosen = FileUtil.toFileObject(file);
                if (FileUtil
                        .isParentOf(myProject.getProjectDirectory(), chosen)
                        || myProject.getProjectDirectory().equals(chosen))
                {
                    String relativePath = FileUtil.getRelativePath(
                            myProject.getProjectDirectory(), chosen);
                    getScanTargetsModel().addElement(
                            BASE_DIR + '/' + relativePath);
                }
                else {
                    getScanTargetsModel().addElement(file.getAbsolutePath());
                }
            }
            addModification();
        }
    }//GEN-LAST:event_showFileChoser

    private void removeSelectedTargets( java.awt.event.ActionEvent evt ) {//GEN-FIRST:event_removeSelectedTargets
        List<?> selected = myScanTargets.getSelectedValuesList();
        for (Object object : selected) {
            getScanTargetsModel().removeElement(object);
        }
    }//GEN-LAST:event_removeSelectedTargets

    private DefaultListModel<String> getScanTargetsModel() {
        return (DefaultListModel<String>) myScanTargets.getModel();
    }

    private List<String> getPomTargets( POMExtensibilityElement scanTargets ) {
        List<POMExtensibilityElement> targets = scanTargets
                .getExtensibilityElements();
        List<String> result = new ArrayList<>(targets.size());
        for (POMExtensibilityElement target : targets) {
            if (target.getQName().getLocalPart().equals(SCAN_TARGET)) {
                result.add(target.getElementText().trim());
            }
        }
        return result;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel canIntervalLbl;

    private javax.swing.JLabel classesDir;

    private javax.swing.JLabel cntxtPathLbl;

    private javax.swing.JScrollPane jScrollPane1;

    private javax.swing.JTextField jTextField1;

    private javax.swing.JButton myAddScan;

    private javax.swing.JTextField myCtxtPath;

    private javax.swing.JTextField myOutputDir;

    private javax.swing.JComboBox myReload;

    private javax.swing.JButton myRemoveScan;

    private javax.swing.JSpinner myScanInterval;

    private javax.swing.JList myScanTargets;

    private javax.swing.JLabel reloadLbl;

    private javax.swing.JPanel scanPanel;

    // End of variables declaration//GEN-END:variables

    private final Project myProject;

    private final ModelHandle2 myHandle;

    private final JettyModification myOperation;

    enum ReloadMode {
        AUTOMATIC,
        MANUAL;

        @Override
        public String toString() {
            return super.toString().toLowerCase();
        }

        static ReloadMode forString( String value ) {
            for (ReloadMode mode : values()) {
                if (mode.toString().equals(value)) {
                    return mode;
                }
            }
            return AUTOMATIC;
        }
    }

    private final class JettyModification implements ModelOperation<POMModel> {

        @Override
        public void performOperation( POMModel model ) {
            Plugin plugin = POMUtils.getJettyPlugin(model);
            if (plugin == null) {
                /*
                 * This shouldn't happen : customizer shouldn't be available if
                 * there is no vaadin plugin
                 */
                return;
            }
            Configuration configuration = plugin.getConfiguration();
            if (configuration == null) {
                createConfiguration(plugin);
                return;
            }
            setOptions(configuration);
        }

        private void setOptions( Configuration configuration ) {
            POMModel model = configuration.getModel();
            List<POMExtensibilityElement> params = configuration
                    .getExtensibilityElements();
            Map<String, POMExtensibilityElement> values = new HashMap<>();
            for (POMExtensibilityElement param : params) {
                values.put(param.getQName().getLocalPart(), param);
            }

            POMUtils.setTextField(CLASSES_DIRECTORY, values, myOutputDir,
                    configuration);
            POMExtensibilityElement reloadMode = values.get(RELOAD);
            ReloadMode mode = (ReloadMode) myReload.getSelectedItem();
            if (reloadMode == null) {
                if (mode != ReloadMode.AUTOMATIC) {
                    configuration.addExtensibilityElement(POMUtils
                            .createElement(model, RELOAD, mode.toString()));
                }
            }
            else if (!POMUtils.getValue(reloadMode).equals(mode.toString())) {
                reloadMode.setElementText(mode.toString());
            }

            if (mode.equals(ReloadMode.AUTOMATIC)) {
                POMExtensibilityElement scanInterval = values
                        .get(SCAN_INTERVAL_SECONDS);
                try {
                    myScanInterval.commitEdit();
                }
                catch (ParseException ignore) {
                }
                Integer scanIntervalValue = (Integer) myScanInterval.getValue();
                String newValue = scanIntervalValue.toString();
                if (scanInterval == null) {
                    if (scanIntervalValue > 0) {
                        configuration.addExtensibilityElement(POMUtils
                                .createElement(model, SCAN_INTERVAL_SECONDS,
                                        newValue));
                    }
                }
                else if (!POMUtils.getValue(scanInterval).equals(newValue)
                        && scanIntervalValue >= 0)
                {
                    scanInterval.setElementText(newValue);
                }
            }

            POMExtensibilityElement webApp = values.get(WEB_APP);
            String ctxtPath = myCtxtPath.getText().trim();
            if (webApp == null) {
                if (ctxtPath.length() != 0) {
                    POMExtensibilityElement ctxtPathElement = POMUtils
                            .createElement(model, CONTEXT_PATH, ctxtPath);
                    webApp = POMUtils.createElement(model, WEB_APP, null);
                    webApp.addExtensibilityElement(ctxtPathElement);
                    configuration.addExtensibilityElement(webApp);
                }
            }
            else {
                List<POMExtensibilityElement> webAppConfs = webApp
                        .getExtensibilityElements();
                Map<String, POMExtensibilityElement> map = new HashMap<>();
                for (POMExtensibilityElement conf : webAppConfs) {
                    if (conf.getQName().getLocalPart().equals(CONTEXT_PATH)) {
                        map.put(CONTEXT_PATH, conf);
                        break;
                    }
                }

                POMUtils.setTextField(CONTEXT_PATH, map, myCtxtPath, webApp);
            }

            POMExtensibilityElement scanTargets = values.get(SCAN_TARGETS);
            setTargets(model, scanTargets);
        }

        private void setTargets( POMModel model,
                POMExtensibilityElement scanTargets )
        {
            if (scanTargets == null) {
                if (!getScanTargetsModel().isEmpty()) {
                    scanTargets = POMUtils.createElement(model, SCAN_TARGETS,
                            null);
                    for (String target : getTargets()) {
                        POMExtensibilityElement newTarget = POMUtils
                                .createElement(model, SCAN_TARGET, target);
                        scanTargets.addExtensibilityElement(newTarget);
                    }
                }
            }
            else {
                List<String> oldTargets = getPomTargets(scanTargets);
                LinkedHashSet<String> targets = getTargets();
                for (POMExtensibilityElement child : scanTargets
                        .getExtensibilityElements())
                {
                    if (child.getQName().getLocalPart().equals(SCAN_TARGET)
                            && !targets.contains(child.getElementText().trim()))
                    {
                        scanTargets.removeExtensibilityElement(child);
                    }
                }
                targets.removeAll(oldTargets);
                for (String target : targets) {
                    POMExtensibilityElement newTarget = POMUtils.createElement(
                            model, SCAN_TARGET, target);
                    scanTargets.addExtensibilityElement(newTarget);
                }
            }
        }

        private LinkedHashSet<String> getTargets() {
            LinkedHashSet<String> result = new LinkedHashSet<>();
            for (int i = 0; i < getScanTargetsModel().size(); i++) {
                result.add(getScanTargetsModel().get(i));
            }
            return result;
        }

        private void createConfiguration( Plugin plugin ) {
            POMModel model = plugin.getModel();
            Configuration configuration = model.getFactory()
                    .createConfiguration();
            setOptions(configuration);
            plugin.setConfiguration(configuration);
        }
    }

    private final class InitRunnable implements Runnable,
            ModelOperation<POMModel>
    {

        @Override
        public void performOperation( POMModel model ) {
            Plugin plugin = POMUtils.getJettyPlugin(model);
            if (plugin == null) {
                return;
            }
            Configuration configuration = plugin.getConfiguration();
            if (configuration == null) {
                return;
            }
            List<POMExtensibilityElement> params = configuration
                    .getExtensibilityElements();
            POMExtensibilityElement webApp = null;
            POMExtensibilityElement scanTargets = null;
            for (POMExtensibilityElement param : params) {
                QName qName = param.getQName();
                String name = qName.getLocalPart();
                String value = param.getElementText().trim();
                switch (name) {
                    case CLASSES_DIRECTORY:
                        classes = value;
                        break;
                    case RELOAD:
                        reload = ReloadMode.forString(value);
                        break;
                    case SCAN_INTERVAL_SECONDS:
                        try {
                            scanInterval = Integer.parseInt(value);
                        }
                        catch (NumberFormatException ignore) {
                        }
                        break;
                    case WEB_APP:
                        webApp = param;
                        break;
                    case SCAN_TARGETS:
                        scanTargets = param;
                        break;
                    default:
                        break;
                }
            }
            if (webApp != null) {
                List<POMExtensibilityElement> webAppConfs = webApp
                        .getExtensibilityElements();
                for (POMExtensibilityElement conf : webAppConfs) {
                    if (conf.getQName().getLocalPart().equals(CONTEXT_PATH)) {
                        ctxtPath = conf.getElementText().trim();
                        break;
                    }
                }
            }

            if (scanTargets != null) {
                additionalScanTargets = getPomTargets(scanTargets);
            }
        }

        @Override
        public void run() {
            NbMavenProject mvnProject = myProject.getLookup().lookup(
                    NbMavenProject.class);
            MavenProject mavenProject = mvnProject.getMavenProject();
            File file = mavenProject.getFile();
            FileObject pom = FileUtil
                    .toFileObject(FileUtil.normalizeFile(file));
            Utilities.performPOMModelOperations(pom,
                    Collections.singletonList(this));

            myCtxtPath.setText(ctxtPath);
            myOutputDir.setText(classes);
            myReload.setSelectedItem(reload);
            myScanInterval.setValue(scanInterval);

            if (myReload.getSelectedItem().equals(ReloadMode.MANUAL)) {
                myScanInterval.setEnabled(false);
            }

            DefaultListModel<String> model = getScanTargetsModel();
            for (String target : additionalScanTargets) {
                model.addElement(target);
            }
        }

        private String classes;

        private String ctxtPath;

        private int scanInterval;

        private ReloadMode reload = ReloadMode.AUTOMATIC;

        private List<String> additionalScanTargets = Collections.emptyList();

    }
}
